using System;
using NBitcoin;
using Stratis.Bitcoin.Features.Wallet;

namespace Stratis.Features.FederatedPeg.Conversion
{
    public enum ConversionRequestType
    {
        Mint,
        Burn
    }

    public enum ConversionRequestStatus
    {
        Unprocessed,
        Submitted, // Unused, need to keep it due to previous state ordering in database
        Processed,

        // States particular to Mint transactions
        OriginatorNotSubmitted,
        OriginatorSubmitted,
        VoteFinalised,
        NotOriginator,
        OriginatorSubmitting
    }

    /// <summary>Request to mint or burn wSTRAX.</summary>
    /// <remarks>
    /// When wSTRAX coins are minted and sent to <see cref="DestinationAddress"/> on ETH chain same amount of STRAX coins should be received by the multisig address.
    /// When wSTRAX coins are burned on ETH chain same amount of STRAX coins should be sent to <see cref="DestinationAddress"/>.
    /// </remarks>
    public class ConversionRequest : IBitcoinSerializable
    {
        /// <summary>
        /// The unique identifier for this particular conversion request.
        /// It gets selected by the request creator.
        /// The request ID is typically the initiating transaction ID.
        /// </summary>
        public string RequestId { get { return this.requestId; } set { this.requestId = value; } }

        /// <summary>
        /// The transaction id on the external chain generated by the submit or confirm transaction action.
        /// <para>A value of 0 indicates unspecified (not yet populated). This was because we added this field in a later release.</para>
        /// </summary>
        public string ExternalChainTxHash { get { return this.externalChainTxHash; } set { this.externalChainTxHash = value; } }

        /// <summary>
        /// The event transaction id returned by calling the contract on the external chain.
        /// </summary>
        public string ExternalChainTxEventId { get { return this.externalChainTxEventId; } set { this.externalChainTxEventId = value; } }

        /// <summary>
        /// The type of the conversion request, mint or burn.
        /// <see cref="ConversionRequestType"/>
        /// </summary>
        public ConversionRequestType RequestType { get { return (ConversionRequestType)this.requestType; } set { this.requestType = (int)value; } }

        /// <summary>
        /// The status of the request, from unprocessed to processed.
        /// </summary>
        public ConversionRequestStatus RequestStatus { get { return (ConversionRequestStatus)this.requestStatus; } set { this.requestStatus = (int)value; } }

        /// <summary>
        /// For a mint request this is needed to coordinate which multisig member is considered the transaction originator on the wallet contract.
        /// A burn request needs to be scheduled for a future block on the main chain so that the conversion can be cleanly inserted into the sequence
        /// of transfers.
        /// </summary>
        public int BlockHeight { get { return this.blockHeight; } set { this.blockHeight = value; } }

        /// <summary>
        /// Either the Ethereum address to send the minted funds to, or the STRAX address to send unwrapped wSTRAX funds to.
        /// </summary>
        public string DestinationAddress { get { return this.destinationAddress; } set { this.destinationAddress = value; } }

        /// <summary>Chain on which STRAX minting or burning should occur.</summary>
        public DestinationChain DestinationChain { get { return (DestinationChain)this.destinationChain; } set { this.destinationChain = (int)value; } }

        /// <summary>
        /// Amount of the conversion, this is always denominated in satoshi. This needs to be converted to wei for submitting mint transactions.
        /// Burn transactions are already denominated in wei on the Ethereum chain and thus need to be converted back into satoshi when the
        /// conversion request is created. Conversions are currently processed 1 ether : 1 STRAX.
        /// </summary>
        public ulong Amount { get { return this.amount; } set { this.amount = value; } }

        /// <summary>
        /// Indicates whether or not this request has been processed by the interop poller.
        /// </summary>
        public bool Processed { get { return this.processed; } set { this.processed = value; } }

        public string TokenContract { get { return this.tokenContract; } set { this.tokenContract = value; } }

        private string requestId;

        private string externalChainTxHash;

        private string externalChainTxEventId;

        private int requestType;

        private int requestStatus;

        private int blockHeight;

        private string destinationAddress;

        private int destinationChain;

        private ulong amount;

        private bool processed;

        private string tokenContract;

        public const string MigrationCharacter = "-";

        public void ReadWrite(BitcoinStream stream)
        {
            stream.ReadWrite(ref this.requestId);
            stream.ReadWrite(ref this.requestType);
            stream.ReadWrite(ref this.requestStatus);
            stream.ReadWrite(ref this.blockHeight);
            stream.ReadWrite(ref this.destinationAddress);
            stream.ReadWrite(ref this.amount);
            stream.ReadWrite(ref this.processed);


            ReadWriteNullIntField(stream, ref this.destinationChain);
            ReadWriteNullStringField(stream, ref this.externalChainTxHash);
            ReadWriteNullStringField(stream, ref this.externalChainTxEventId);
            ReadWriteNullStringField(stream, ref this.tokenContract);

            //try
            //{
            //    // InterFlux v2 fields
            //    stream.ReadWrite(ref this.destinationChain);
            //    stream.ReadWrite(ref this.externalChainTxHash);
            //    stream.ReadWrite(ref this.externalChainTxEventId);
            //}
            //catch (Exception)
            //{
            //    // The above fields were not present in InterFlux v1.
            //}

            //try
            //{
            //    // InterFlux v3 fields
            //    stream.ReadWrite(ref this.tokenContract);
            //}
            //catch (Exception)
            //{
            //    // The above fields were not present in InterFlux v1/2.
            //}
        }

        private void ReadWriteNullIntField(BitcoinStream stream, ref int nullField)
        {
            try
            {
                stream.ReadWrite(ref nullField);
            }
            catch (Exception)
            {
                nullField = -1;
                stream.ReadWrite(ref nullField);
            }
        }

        private void ReadWriteNullStringField(BitcoinStream stream, ref string nullField)
        {
            try
            {
                stream.ReadWrite(ref nullField);
            }
            catch (Exception)
            {
                nullField = MigrationCharacter;
                stream.ReadWrite(ref nullField);
            }
        }
    }
}
